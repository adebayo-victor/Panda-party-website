# Import the CS50 library to handle database connections and queries.
from cs50 import SQL
import uuid # Import uuid for generating unique codes
from datetime import datetime # Import datetime for purchase_date

# Establish a connection to the database.
# This will create a file named "party.db" if it does not already exist.
db = SQL("sqlite:///party.db")

# ----------------------------------------------------------------------
# DATABASE SETUP: Create tables and insert dummy data
# ----------------------------------------------------------------------

# Drop existing tables to ensure a clean slate every time the script is run.
# This is useful for testing and demonstration purposes.
db.execute("DROP TABLE IF EXISTS ticket_purchases;")
db.execute("DROP TABLE IF EXISTS ticket_info;")
db.execute("DROP TABLE IF EXISTS clients;")

# Create the clients table with columns for name, email (unique), password hash, and phone number.
db.execute("""
    CREATE TABLE clients (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE,
        password_hash TEXT NOT NULL,
        phone_number TEXT NOT NULL,
        address TEXT -- Added address as per frontend form
    );
""")

# Create the ticket_info table to store the names of different tickets.
# Updated to include price (using REAL for floating-point numbers) and description.
db.execute("""
    CREATE TABLE ticket_info (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        price REAL NOT NULL,
        description TEXT
    );
""")

# Create the ticket_purchases table to link clients and tickets.
# It includes foreign key constraints to ensure data integrity.
# Added unique_code and status columns
db.execute("""
    CREATE TABLE ticket_purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        client_id INTEGER NOT NULL,
        ticket_id INTEGER NOT NULL,
        purchase_date TEXT NOT NULL,
        unique_code TEXT NOT NULL UNIQUE,  -- Added unique_code
        status TEXT NOT NULL DEFAULT 'unredeemed', -- Added status
        FOREIGN KEY (client_id) REFERENCES clients(id),
        FOREIGN KEY (ticket_id) REFERENCES ticket_info(id)
    );
""")

# Insert dummy data into the clients table.
# Added dummy address for clients
db.execute("""
    INSERT INTO clients (name, email, password_hash, phone_number, address) VALUES
    ('Jane Doe', 'jane.doe@example.com', 'hashed_password_123', '555-1234', '123 Main St'),
    ('John Smith', 'john.smith@example.com', 'hashed_password_456', '555-5678', '456 Oak Ave'),
    ('Alice Johnson', 'alice.j@example.com', 'hashed_password_789', '555-9012', '789 Pine Ln');
""")

# Insert specific ticket info for Platinum, VIP, and Regular
db.execute("""
    INSERT INTO ticket_info (name, price, description) VALUES
    ('Platinum', 15000.00, 'The ultimate experience with exclusive benefits. Includes VIP seating, meet & greet, and complimentary items.'),
    ('VIP', 10000.00, 'An elevated experience with premium perks. Includes reserved seating, VIP lounge access, and a complimentary drink.'),
    ('Regular', 5000.00, 'Standard access to all general areas and amenities.');
""")

# Get the IDs of the newly inserted ticket types
platinum_ticket_id = db.execute("SELECT id FROM ticket_info WHERE name = 'Platinum'")[0]['id']
vip_ticket_id = db.execute("SELECT id FROM ticket_info WHERE name = 'VIP'")[0]['id']
regular_ticket_id = db.execute("SELECT id FROM ticket_info WHERE name = 'Regular'")[0]['id']

# Get current datetime for purchase dates
current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# Insert dummy data into the ticket_purchases table for our clients.
# Now using the specific ticket IDs and generating unique codes and statuses.
db.execute("""
    INSERT INTO ticket_purchases (client_id, ticket_id, purchase_date, unique_code, status) VALUES
    (1, ?, ?, ?, ?),  -- Jane Doe: Platinum Ticket
    (1, ?, ?, ?, ?),  -- Jane Doe: Regular Ticket
    (2, ?, ?, ?, ?),  -- John Smith: VIP Ticket
    (1, ?, ?, ?, ?);  -- Jane Doe: VIP Ticket (another one)
""",
   platinum_ticket_id, current_datetime, str(uuid.uuid4()), 'unredeemed',
   regular_ticket_id, current_datetime, str(uuid.uuid4()), 'unredeemed',
   vip_ticket_id, current_datetime, str(uuid.uuid4()), 'redeemed', # Example of a redeemed ticket
   vip_ticket_id, current_datetime, str(uuid.uuid4()), 'unredeemed')

# ----------------------------------------------------------------------
# QUERY EXECUTION: Find tickets for a specific client
# ----------------------------------------------------------------------

# Define the email address of the client you want to search for.
client_email = "jane.doe@example.com"

# Execute the SQL query to find the client's purchased tickets.
# The query is updated to select the new price, description, unique_code, and status columns.
tickets = db.execute("""
    SELECT
        c.id AS client_id, -- Added client_id for frontend use
        c.name AS client_name,
        c.email AS client_email,
        c.phone_number,
        c.address, -- Selected address
        ti.name AS ticket_name,
        ti.price,
        ti.description,
        tp.purchase_date,
        tp.unique_code,  -- Selected unique_code
        tp.status        -- Selected status
    FROM
        clients AS c
    JOIN
        ticket_purchases AS tp ON c.id = tp.client_id
    JOIN
        ticket_info AS ti ON tp.ticket_id = ti.id
    WHERE
        c.email = ?
    ORDER BY
        tp.purchase_date DESC;
""", client_email)

# Check if any tickets were found.
if tickets:
    # Print the client's details just once at the beginning.
    print(f"Client Details:")
    print("-" * 50)
    print(f"ID:            {tickets[0]['client_id']}")
    print(f"Name:          {tickets[0]['client_name']}")
    print(f"Email:         {tickets[0]['client_email']}")
    print(f"Phone Number:  {tickets[0]['phone_number']}")
    print(f"Address:       {tickets[0]['address']}")

    # Print a header for the tickets.
    print("\nTickets Purchased:")
    print("-" * 50)
    
    # Iterate through the returned rows and print the details of each ticket.
    # The print statements are updated to show the new price, description, unique_code, and status.
    for ticket in tickets:
        print(f"Ticket Name:   {ticket['ticket_name']}")
        print(f"Price:         ${ticket['price']:.2f}")
        print(f"Description:   {ticket['description']}")
        print(f"Purchase Date: {ticket['purchase_date']}")
        print(f"Unique Code:   {ticket['unique_code']}")
        print(f"Status:        {ticket['status']}")
        print("-" * 50)
else:
    # If no tickets were found, print a message.
    print(f"No tickets found for the client with email: {client_email}.")


const forms = document.querySelectorAll('form');
            forms.forEach(form => {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const ticketName = form.querySelector('input[name="ticket_name"]').value;
                    const ticketPrice = form.querySelector('input[name="ticket_price"]').value;

                    showMessage(`Preparing to purchase a ${ticketName} ticket for N${ticketPrice}...`);
                    
                    try {
                        // Create FormData object directly from the form
                        const formData = new FormData(form);
                        
                        // Send the FormData directly in the body
                        const response = await fetch(form.action, {
                            method: 'POST',
                            body: formData, // Send as FormData, browser will set Content-Type
                            mode:'cors'
                        });

                        const result = await response.json(); // Still expect JSON response from backend
                        if (response.ok) {
                            // Assuming the backend returns a redirection URL or a Paystack authorization URL
                            showMessage('Payment initiated successfully! Redirecting...');
                            // window.location.href = result.authorization_url;
                        } else {
                            showMessage(result.message || 'Payment initiation failed. Please try again.');
                        }
                    } catch (error) {
                        showMessage('An error occurred while processing your request.');
                    }
                });
            });